<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="three.js"></script>
    <script src="PLYLoader.js"></script>
    <script src="OrbitControls.js"></script>
</head>
<body>
<script>
        const renderer = new THREE.WebGLRenderer;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        const light = new THREE.PointLight(0xFFFFFF);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        const raycaster = new THREE.Raycaster();
        const polypoints = [];
        controls.addEventListener('change',render);
        light.position.set(0.5,-10,4);
        scene.add(light);
        camera.position.set(1, -5, 5);
        camera.lookAt(new THREE.Vector3(0,0,0));
        const meshLoader = new THREE.PLYLoader();
        let mesh;
        document.body.appendChild( renderer.domElement );
        renderer.setSize( window.innerWidth, window.innerHeight );
        meshLoader.load('pecksm.nxz-small.ply', function(bufferGeometry){
            // use normal geom instead of buffergeometry b/c easier to color faces
            let geometry = new THREE.Geometry().fromBufferGeometry( bufferGeometry );
            const material = new THREE.MeshPhongMaterial({color: "grey",
                vertexColors: THREE.FaceColors,
                side: THREE.DoubleSide});
            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            render()
        });

        renderer.domElement.addEventListener('mousedown', addPolyPoint);

        function addPolyPoint(evt) {
            raycaster.setFromCamera(
                new THREE.Vector2(
                    ( event.clientX / window.innerWidth ) * 2 - 1, // Mouse position normalized to between -1 and +1
                    - ( event.clientY / window.innerHeight ) * 2 + 1),
                camera
            );
            let intersects = raycaster.intersectObjects([mesh]);
            if (intersects.length > 0) {
                polypoints.push(intersects[0]);
                intersects[0].face.color.set("blue");
                mesh.geometry.colorsNeedUpdate = true;
            };
            console.log(polypoints);
        };

        function render(){
            requestAnimationFrame( render );
            renderer.render(scene, camera);
        };

        function adjacency(geom){
            // Create an array of empty arrays, one for each vertex
            let facesByVertex = [...Array(geom.vertices.length).keys()].map(i=>[]);
            // Add faces to the array position for each vertex they touch
            for (face of geom.faces){
                for (vertex of [face.a, face.b, face.c]){
                    facesByVertex[vertex].push(face);
                }
            }
            return facesByVertex;
        }

//         animate()
    </script>
</body>
</html>
